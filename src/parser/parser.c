/**
 * @file parser.c
 *
 * Parses a line of instruction into an Instruction struct (see @class Instruction.c) by tokenizing the instruction
 * into buckets (see @class Lexer.c) and parsing the buckets into an Instruction struct.
 */

#include "parser.h"

const char* DELIMITERS = " \r\n";
const char* STR_PARAM_MERGE_SPLITTER = " ";

static int count_leading_whitespace(char* str_instruction) {
    assert(str_instruction != NULL, "Attempting to count leading whitespace from NULL string.");

    for (char* current = str_instruction; *current; current++) {
        if (*current != ' ' && *current != '\t') {
            return (int)(current - str_instruction);
        }
    }

    return 0;
}

static InstructionType parse_and_set_type(Instruction* instruction, StrBucket* buckets) {
    StrList* type_bucket = str_bucket_get_bucket(buckets, 0);

    int num_tokens = str_list_get_size(type_bucket);
    assert(num_tokens == 1, "Instruction type must be a single token.");

    const char* str_type = str_list_get_str(type_bucket, 0);
    int type_idx = str_array_find(InstructionTypeLookupArray, NUM_INSTRUCTION_TYPES, str_type);
    assert(type_idx != -1, "Instruction type does not exist.");

    instruction_set_type(instruction, type_idx);

    return type_idx;
}

static void parse_and_set_id(Instruction* instruction, StrBucket* buckets) {
    StrList* type_bucket = str_bucket_get_bucket(buckets, 1);

    char* id = str_list_concatenate(type_bucket, STR_PARAM_MERGE_SPLITTER);
    instruction_set_id(instruction, id);

    free(id);
}

/**
 * Sets an alias for the instruction id. The alias is generated by the instruction map to ensure uniqueness. Alias' are
 * used to reference instructions in transactions such as "press" operations for "press" instructions. For example,
 * "press a" has no id, so we generate an id in the form an alias so it can be referenced by other instructions.
 *
 * @param instruction
 * @param buckets
 */
static void set_alias_id(Instruction* instruction, StrBucket* buckets) {
    StrList* type_bucket = str_bucket_get_bucket(buckets, 1);
    char* original_id = str_list_concatenate(type_bucket, STR_PARAM_MERGE_SPLITTER);

    char* alias_id = instruction_map_generate_alias(original_id);
    instruction_set_id(instruction, alias_id);

    free(alias_id);
    free(original_id);
}

/**
 * Attempts to parse the instruction parameter as a button. A button parameter is a parameter that contains a single
 * configuration for a keystroke.
 * @param instruction
 * @param parameter_bucket
 * @return
 */
static bool try_set_parameter_as_button(Instruction* instruction, StrBucket* parameter_bucket) {
    const int num_tokens = str_list_get_size(parameter_bucket);
    const char* str_param = str_list_get_str(parameter_bucket, 0);

    if(strcmp(str_param, "button") != 0) {
        return false;
    }

    assert(num_tokens == 2, "Button parameter must contain exactly one token.");

    char* button_str = str_list_get_str(parameter_bucket, 1);

    Key* key = key_map_get(button_str);
    assert(key != NULL, "Button parameter must be a valid key (found : %s).", button_str);

    const unsigned short keycode = key->code;
    instruction_set_keycode(instruction, keycode);

    return true;
}

/**
 * Attempts to parse the instruction parameter as a known parameter. A known parameter is a pre-defined parameter such
 * as "delay" and follows the format <parameter name> <lower value> <upper value> or <parameter name> <value>. For
 * example, "delay 1 2" or "delay 1".
 *
 * @param instruction
 * @param parameter_bucket
 * @return
 */
static bool try_set_known_parameters(Instruction* instruction, StrBucket* parameter_bucket) {
    const int num_tokens = str_list_get_size(parameter_bucket);
    assert(num_tokens >= 1, "Instruction parameter must contain at least a one token.");

    char* str_param = str_list_get_str(parameter_bucket, 0);
    const int param_idx = str_array_find(InstructionParameterLookupArray, NUM_INSTRUCTION_PARAMETERS, str_param);
    const bool is_defined_param = param_idx != -1;

    if(is_defined_param == false) {
        return false;
    }

    if(num_tokens == 2) {
        const char *str_lower_value = str_list_get_str(parameter_bucket, 1);
        const int lower_value = atoi(str_lower_value);
        instruction_set_parameter_lower_value(instruction, param_idx, lower_value);
        instruction_set_parameter_upper_value(instruction, param_idx, lower_value);
        return true;
    }

    if(num_tokens == 3) {
        const char *str_lower_value = str_list_get_str(parameter_bucket, 1);
        const char *str_upper_value = str_list_get_str(parameter_bucket, 2);
        const int lower_value = atoi(str_lower_value);
        const int upper_value = atoi(str_upper_value);
        instruction_set_parameter_lower_value(instruction, param_idx, lower_value);
        instruction_set_parameter_upper_value(instruction, param_idx, upper_value);
        return true;
    }

    assert(false, "Instruction known parameter must contain exactly one or two values.");
}

/**
 * Attempts to parse the instruction parameter as a scheduler. A scheduler parameter is a parameter that initializes a
 * series or time-based collection (e.g., routine, scheduler, random queue).
 *
 * @param instruction
 * @param parameter_bucket
 * @return
 */
static bool try_parse_transaction_scheduler_parameter(Instruction* instruction, StrBucket* parameter_bucket) {
    const InstructionType type = instruction_get_type(instruction);
    const bool is_scheduler = instruction_type_is_scheduler(type);
    const bool is_transaction = instruction_type_is_transaction(type);

    if(is_scheduler == false && is_transaction == false) {
        return false;
    }

    char* str_merged_params = str_list_concatenate(parameter_bucket, STR_PARAM_MERGE_SPLITTER);
    instruction_add_sub_instruction(instruction, str_merged_params);
    free(str_merged_params);

    return true;
}

/**
 * Attempts to parse the instruction parameter as a transaction. A transaction parameter is a parameter that contains
 * references to sub instructions. For example, "start something", where "something" is a reference to, for example, a
 * routine, or "press a", where "a" is a keystroke. Keystrokes are saved as another instruction object and referenced by
 * the transaction instruction object.
 *
 * @param instruction
 * @param parameter_bucket
 * @return
 */
static bool try_parse_transaction_parameter(Instruction* instruction, StrBucket* parameter_bucket) {
    const InstructionType type = instruction_get_type(instruction);
    const bool is_transaction = instruction_type_is_transaction(type);
    if(is_transaction == false) {
        return false;
    }

    char* str_merged_params = str_list_concatenate(parameter_bucket, STR_PARAM_MERGE_SPLITTER);
    instruction_add_sub_instruction(instruction, str_merged_params);
    free(str_merged_params);

    return true;
}

/**
 * Attempts to parse the instruction parameter as a reference to another instruction. When a reference is found, the
 * referenced instruction's parameters replaces the same parameters in the current instruction. If the current
 * instruction does not have the same parameters as the referenced instruction, only the parameters that are present
 * in both instructions are replaced.
 *
 * @param instruction
 * @param parameter_bucket
 * @return
 */
static bool try_parse_ref_instruction(Instruction* instruction, StrBucket* parameter_bucket) {
    const char* str_merged_params = str_list_concatenate(parameter_bucket, STR_PARAM_MERGE_SPLITTER);
    Instruction* ref_instruction = instruction_map_get(str_merged_params);

    if (ref_instruction == NULL) {
        return false;
    }

    instruction_copy_values(instruction, ref_instruction);
    free(str_merged_params);
    return true;
}

/**
 * Parses a single bucket into an instruction parameter. The parameter is then set into the instruction.
 *
 * This function is simply a director, calling each parameter parsing function until one of them succeeds. If none of
 * them succeed, then the instruction parameter is invalid and the program will exit. Each parameter is mutually
 * exclusive, so only one of them can succeed; one of them will always succeed if the instruction is valid.
 *
 * @param instruction
 * @param buckets
 * @param bucket_idx
 */
static void parse_and_set_parameter(Instruction* instruction, StrBucket* buckets, int bucket_idx) {
    StrBucket* parameter_bucket = str_bucket_get_bucket(buckets, bucket_idx);

    if(try_set_parameter_as_button(instruction, parameter_bucket) == true) {
        return;
    }

    if (try_set_known_parameters(instruction, parameter_bucket) == true) {
        return;
    }

    if (try_parse_transaction_scheduler_parameter(instruction, parameter_bucket) == true) {
        return;
    }

    if (try_parse_transaction_parameter(instruction, parameter_bucket) == true) {
        return;
    }

    if (try_parse_ref_instruction(instruction, parameter_bucket) == true) {
        return;
    }

    assert(false, "Instruction parameter is invalid.");
}

/**
 * Parses a line of instruction into an Instruction struct.
 *
 * The lexer is used to bucket the instruction. The parser is used to parse the buckets into an Instruction struct. Each
 * bucket represents a single parameter of the instruction. See @class Lexer.c for more information on how the buckets
 * are created.
 *
 * @param instruction
 * @param str_instruction
 */
void parse_line_into_instruction(Instruction* instruction, char* str_instruction) {
    assert(instruction != NULL, "Attempting to parse instruction behind NULL pointer.");
    assert(str_instruction != NULL, "Attempting to parse NULL instruction string.");

    // Set the indent count of the instruction.
    // Indent counts are used to determine the hierarchy of instructions.
    int indent_count = count_leading_whitespace(str_instruction);
    instruction_set_indent_count(instruction, indent_count);

    // Tokenize the instruction into buckets. If the buckets are null, then the instruction is invalid and the
    // instruction is not parsed into (i.e., remains unchanged).
    StrBucket* buckets = tokenize_to_buckets(str_instruction, DELIMITERS);
    if (buckets == NULL) {
        return;
    }

    const int num_buckets = str_bucket_get_size(buckets);
    assert(num_buckets >= 2, "Invalid instruction bucket (expected at least 2, got %d).", num_buckets);

    const InstructionType type = parse_and_set_type(instruction, buckets);
    const bool is_transaction_type = instruction_type_is_transaction(type);
    int bucket_param_idx = 1;

    if(is_transaction_type == false) {
        parse_and_set_id(instruction, buckets);
        bucket_param_idx++;
    } else {
        set_alias_id(instruction, buckets);
    }

    for(; bucket_param_idx < num_buckets; bucket_param_idx++) {
        parse_and_set_parameter(instruction, buckets, bucket_param_idx);
    }

    str_bucket_delete(&buckets);
}